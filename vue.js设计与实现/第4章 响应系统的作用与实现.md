### 响应式数据与副作用函数
副作用函数指的是会产生副作用的函数，假设一个副作用函数读取了某个对象的值，当这个对象的值发生变化是，会重新执行effect副作用函数，如果实现这个目标，则这个对象就是响应式数据

### 响应式数据的基本实现
- 当副作用函数effect执行时，会触发字段的<b>读取</b>操作
- 当修改对象值时，会触发字段的<b>设置</b>操作
> es2015之前使用`Object.defineProperty`函数实现
> es2015+之后使用代理对象`Proxy`来实现

### 设计一个完善的响应系统
- 当<b>读取</b>操作发生时，将副作用函数收集到“桶”中
- 当<b>设置</b>操作发生时，从”桶“中取出副作用函数并执行

```js
// 仅使用Set作为“桶”，使得副作用函数与被操作的目标字段之间没有建立明确的联系
// 导致任意修改对象值，都会触发effect
const bucket = new Set()
const data = { text: 'hello effect' } 

let activeEffect = null

function effect(fn) {
	activeEffect = fn
	fn()
}

const obj = new Proxy(data, {
	get(target, key) {
		if(activeEffect) {
			bucket.add(activeEffect)
		}	
		return target[key]
	},
	set(target, key, newVal) {
		target[key] = newVal
		bucket.forEach(fn => fn())
		return true
	}
})

effect(() => {
	// document.body.innerText = obj.text
	console.log(obj.text)
})

setTimeout(() => {
	obj.notExist = 'hello vue3'
}, 1000)

```

>仅使用Set作为“桶”，使得副作用函数与被操作的目标字段之间没有建立明确的联系
>导致任意修改对象值，都会触发effect

代理对象target, 被操作的字段名key, 被注册的副作用函数effectFn， 三个角色的关系是一种树状结构
```js
const bucket = new WeakMap()
const data = { text: 'hello effect' }
let activeEffect = null
function effect(fn) {
	activeEffect = fn
	fn()
}

const obj = new Proxy(data, {
	get(target, key) {
		if (!activeEffect) return
		let depsMap = bucket.get(target)
		if (!depsMap) {
			bucket.set(target, (depsMap = new Map()))
		}
		
		let deps = depsMap.get(key)
		if (!deps) {
			depsMap.set(key, (deps = new Set()))
		}
		
		deps.add(activeEffect)
		return target[key]
	},

	set(target, key, newVal) {
		target[key] = newVal
		const depsMap = bucket.get(target)
		if (!depsMap) return
		const effects = depsMap.get(key)
		effects && effects.forEach(fn => fn())
	}

})  

effect(() => {
	// document.body.innerText = obj.text
	console.log(obj.text)
})

setTimeout(() => {
	obj.notExist = 'hello vue3'
	obj.text = 'update text'
}, 1000)

```
- WeakMap 由target --> Map构成
- Map 由key--> Set构成
> WeakMap 对key是弱应用，不影响垃圾回收器的工作

更好的封装，收集副作用**跟踪**函数track，**触发**副作用的函数trigger
```js
const bucket = new WeakMap()
const data = { text: 'hello effect' }
let activeEffect = null
function effect(fn) {
	activeEffect = fn
	fn()
}

const obj = new Proxy(data, {
	get(target, key) {
		track(target, key)
		return target[key]
	},
	
	set(target, key, newVal) {
		target[key] = newVal
		trigger(target, key)
	}

})

// 收集副作用跟踪函数track
function track(target, key) {
	if (!activeEffect) return
		let depsMap = bucket.get(target)
		if (!depsMap) {
		bucket.set(target, (depsMap = new Map()))
	}
	let deps = depsMap.get(key)
	if (!deps) {
		depsMap.set(key, (deps = new Set()))
	}
	deps.add(activeEffect)

}

// 触发副作用的函数trigger
function trigger(target, key) {
	const depsMap = bucket.get(target)
	if (!depsMap) return
	const effects = depsMap.get(key)
	effects && effects.forEach(fn => fn())
}

effect(() => {
	// document.body.innerText = obj.text
	console.log(obj.text)
})

setTimeout(() => {
	obj.notExist = 'hello vue3'
	obj.text = 'update text'
}, 1000)

```             

### 分支切换与cleanup
根据字段值得不同执行不同的代码分支，这就是分支切换
分支切换会产生遗留的副作用函数，导致不必要的更新，所以在副作用函数执行时候，要把它从所有与之关联的依赖集合中删除
- 在